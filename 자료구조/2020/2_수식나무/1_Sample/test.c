//-------------------------------------------------------------------
// Tree 응용 
// 수식 나무 (Parse Tree)를 이용한 수식 표기법 변경 
//-------------------------------------------------------------------

/*
//-------------------------------------------------------------------
1. 수식의 표기법
//-------------------------------------------------------------------

  1) 중위 표기법(Infix notation)
     수학 시간에 배우고 흔히 사용하는 수식의 표현 방법
	 A * ( ( B + C ) / ( D - E ) ) 

	 => 피연산자 연산자 피연산자 
	    ex1)  B      +      C
		ex2)  A  +  B  *  C  - D  /  E  +  F  *  G   

  2) 후위 표기법(Postfix notation)
     => 피연산자 피연산자 연산자
	    ex1)  B       C      + 
		ex2)  A  B  +  C  D  -  *  E  /  F  G  *  +

  3) 전위 표기법(Prefix notation)
     => 연산자 피연산자  피연산자
        ex1)  +       B       C
		ex2)  +  /  *  *  E  F  G  +  -  A  B  C  D
*/



//-------------------------------------------------------------------
// 2. 수식나무의 기본 개념 
//-------------------------------------------------------------------
/*
  수식나무는 수식의 평가나 수식의 표기법을 변환하는데 사용 
  연산자를 뿌리로 하고 
  왼쪽 피연산자를 왼쪽 자식 나무에 
  오른쪽 피연산자를 오른쪽 자식 나무에 놓는 구조 

   ((( A + B) * ( C - D ) ) / E ) + ( F * G )

						+
				 /				*

			*	    E      F        G

  	    +       -

	A    B    C    D

   ==> 외부 노드들은 모두 피연산자이고 
       내부 노드들은 모두 연산자이다.
*/


//-------------------------------------------------------------------
// 3. 후위표기법에서 수식 나무를 구성하는 방법 
//-------------------------------------------------------------------
/*
	1) 피연산자를 만나면  노드를 생성하여 스택에 푸시한다.
	2) 연산자를 만나면 노드를 생성하여 
	   2,1) 스택에서 팝한 노드를 오른쪽 자식으로 할당하고
	   2.2) 스택에서 또 팝한 노드를 왼쪽 자식으로 할당한다.
	   2.3) 그리고 연산자르 노드를 스택에 푸시한다.
	3) 스택에서 마지막으로 남은 노드가 뿌리노드이다.
*/

//-------------------------------------------------------------------
// 4. 알고리즘 생성 과정 
//-------------------------------------------------------------------
/*
	A B + C D - * E / F G * + 

	[ 스택 모양 ]

	(1)  피연산자인 A, B를 차례로 스택에 푸시 
    (2) + 연산자를 만나면 스택에서 팝한 A와 B를 자식으로 두고 
	    +연산자를 스택에 푸시한다.
		==> A와 B노드는 실제로 스택에 저장되는 것은 아니다.

    (3) C와 D를 차례로 스택에 푸시한다.
	(4) - 연산자를 만나면 스택에서 팝한 C와 D를 자식으로 두고 
	    - 연산자를 스택에 푸시한다.
	(5) *연산자를 만나면 +와 -를 자식으로 두고 *연산자를 푸시한다.
	(6) E는 피연산자이므로 푸시한다.
	(7) / 연산자를 만나면 팝한 *와 E를 자식으로 두고 / 연산자를 
	    푸시한다. 
		계속해서 F와 G는 피연산자이므로 스택에 푸시한다.
	(8) *연산자가 입력되면 스택에서 F와 G를 팝하여 *연산자의 
	    자식으로 두고 *연산자를 스택에 푸시한다.
	(9) 마지막으로 +연산자는 스택에서 팝한 /와 *를 자식으로 
	    두고 스택에 푸시한다.
   

//-------------------------------------------------------------------
// 5. 코드 구현 및 실행 
//-------------------------------------------------------------------
	std.h     : 필요한 h파일 추가 
	caltree.h : 함수 선언 및 구조체 선언
	caltree.c : 함수의 구현부
	main.c    : 동작부분

*/
