/**********************************************************
 [ Object Initialze ] 
**********************************************************/

/*
 대부분의 data 멤버는 private에 선언된다.
 Private 멤버를 외부에서 초기화 할 수 없다.
 객체의 멤버를 초기화 할 방법이 필요하다.

struct Point
{
	int x;
	int y;
};

void main()
{
	Point p1 = { 10, 20 }; // Ok
}


class Point
{
	int x;
	int y;
};

void main()
{
	Point p1 = { 10, 20 }; // Error
}

--------------------------------------------------
일반적의 변수를 만들 때 초기화 할 수 있다.
Int n = 0;

구조체 역시 만들면서 초기화 할 수 있다.
Point p1 = { 10, 20 };

하지만 만약 data멤버가 private에 있다면 외부에서 
data멤버에 접근할수 없으므로 초기화할수 없다.

Struct Point 
{
Private:
	int x, y;
};
Point p1 = { 10, 20 }; // Error

Class 는 접근지정자가 디폴트로 private이므로 역시 아래 
예제 역시 에러이다.

Class Point
{
	int x, y;
};
Point p1 = { 10, 20 }; // Error

private에 있는 data도 초기화 할수 있는 다른 방법이 필요 하다 

*/

/*
==========================================================
[ 생성자 ]
==========================================================
형태
 클래스 이름과 동일한 이름을 갖는다.
 리턴 형이 없으며 리턴 하지 않는다.
 파라 미터를 갖을 수 있다.(Overloading이 가능하다)

특징
 객체가 생성될 때 반드시 1번 호출된다.
 프로그래머가 정의해주지 않으면 디폴트 생성자가 
  자동으로 만들어 진다.
  (디폴트 생성자 : 인자를 받지 않으며, 하는 일이 없다.)
 명시적으로 생성자를 호출할 수는 없다.
 하나의 생성자에서 또 다른 생성자를 호출할 수 없다.

class Point
{
private:
	int x;
	int y;
public:
	Point()	{		x = 0;		y = 0;	}
	Point( int _x, int _y)	{		x = _x;		y = _y;	}
}
void main()
{
	Point p1;
	Point p2(10,20);
}

Point point;
 Point클래스의 크기만큼 메모리가 할당된다.
 Point의 생성자가 호출된다.

-----------------------------------------------------
*) 객체가 멤버로 다른 객체를 포함 하고 있을 경우 
   객체가 멤버로 다른 객체를 포함하고 있을 경우를 
   생각해 보자. 아래 코드를 보자

class Point
{
public:
	Point() { cout << “Point 생성자” << endl;}
};

class Rect
{
	Point p1;
	Point p2;
public:
	Rect() { cout << “Rect 생성자” << endl;}
};

void main()
{
	Rect r;
}

화면에 출력되는 결과를 예측해 보자.
결국,.....

  










1. 객체의 구성하는 요소의 생성자가 먼저 호출되고 
   ( 위 코드의 경우 Point )
2. 객체 자신의 생성자가 호출된다.( Rect )

*/

/*
==========================================================
[ 생성자가 호출되는 다양한 경우 
==========================================================
class Point
{
private:
	int x, y;
public:
	Point() : x(0), y(0) { cout << "생성자1" << endl;}
	
	Point(int _x, int _y): x(_x), y(_y) { cout << "생성자2" << endl;}
};

void main()
{
	Point p1;
	Point p2 = Point();

	Point p3(1,2);
	Point p4 = Point(1,2);

	Point p5[5];
	Point p6[5] = { Point(1,2),Point(2,3) };

	Point* p7;
	p7 = new Point;
	Point* p8 = new Point(1,2);

	delete p7;
	delete p8;
}

-----------------------------------------------------
객체가 메모리에 생성되면 반드시 생성자가 호출된다.
객체의 배열을 만들 때는 배열의 개수만큼 디폴트 생성자가 
호출된다. 아래 표현은 디폴트 생성자가 5번 호출된다.
Point p5[5];

배열을 만들때 특정 생성자를 호출되게 하려면 아래처럼 
하면 된다.
Point p6[5] = { Point(1,2), Point(2,3) }

포인터 변수를 만드는 것은 객체가 만들어 지는 것이 
아니므로 생성자를 호출하지는 않는다.
Point* p7;

하지만 아래 코드는 Heap에 객체가 만들어 지므로 생성자가 
호출된다.
p7 = new Point;
Point* p8 = new Point(1,2);




*/